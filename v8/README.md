V8
--


<!-- vim-markdown-toc GFM -->

* [V8内存限制](#v8内存限制)
* [v8 堆构成](#v8-堆构成)
* [GC 回收类型](#gc-回收类型)
* [内存泄漏的途径](#内存泄漏的途径)

<!-- vim-markdown-toc -->

## V8内存限制

内存使用超过限制会造成进程退出

64 位内存使用:

新生代: 1.4G
老生代: 64M

32 位内存使用:

新生代: 0.7G
老生代: 32M

通过node --max-old-space-size=xxx（单位MB） , node --max-new-space-size=xxx（单
位KB） 设置新生代内存以及老生代内存来破解默认的内存限制。


## v8 堆构成

V8 的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：

- 新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁

- 老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，
  大多数从新生代晋升的对象会被移动到这里

- 老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的
  指针

- 大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其
  不会移动大对象

- 代码区：代码对象，也就是包含 JIT 之后指令的对象，会被分配在这里。唯一拥有执行
  权限的内存区

- Cell 区、属性 Cell 区、 Map 区：存放 Cell 、属性 Cell 和 Map ，每个区域都是存
  放相同大小的元素，结构简单

## GC 回收类型

增量式GC:

表示垃圾回收器在扫描内存空间时是否收集（增加）垃圾并在扫描周期结束时清空垃圾。

非增量式GC:

使用非增量式垃圾收集器时，一收集到垃圾即将其清空。

垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。对象
首先进入占用空间较少的新生代内存。大部分对象会很快失效，非增量GC直接回收这些少
量内存。假如有些对象一段时间内不能被回收，则进去老生代内存区。这个区域则执行不
频繁的增量GC，且耗时较长。

## 内存泄漏的途径

- 内存泄露
- 缓存
- 队列消费不及时
- 作用域未释放

> Node的内存构成主要是通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限
> 制的主要是V8的堆内存。造成内存泄漏的主要原因：

1. 缓存
2. 队列消费不及时
3. 作用域未释放
